package main

import (
	"fmt"
	"math/rand"
	"time"

	"github.com/zehlt/gelly"
	"github.com/zehlt/go6502"
)

func mapByteToColor(bi byte) gelly.Color {
	switch bi {
	case 0:
		return gelly.Color{R: 0, G: 0, B: 0, A: 255}
	case 1:
		return gelly.Color{R: 255, G: 255, B: 255, A: 255}
	case 2, 9:
		return gelly.Color{R: 255, G: 255, B: 255, A: 255}
	case 3, 10:
		return gelly.Color{R: 255, G: 0, B: 0, A: 255}
	case 4, 11:
		return gelly.Color{R: 0, G: 255, B: 0, A: 255}
	case 5, 12:
		return gelly.Color{R: 0, G: 0, B: 255, A: 255}
	case 6, 13:
		return gelly.Color{R: 255, G: 0, B: 255, A: 255}
	case 7, 14:
		return gelly.Color{R: 255, G: 255, B: 0, A: 255}
	default:
		return gelly.Color{R: 0, G: 255, B: 0, A: 255}
	}
}

const CELL_SIZE int = 22
const GRID_WIDTH int = 32
const GRID_SIZE int = GRID_WIDTH * GRID_WIDTH

type GesnoEmul struct {
	isLost bool

	font gelly.Font
	cpu  go6502.Cpu
	mem  go6502.Mem

	dispatcher *gelly.EventDispatch
}

func (s *GesnoEmul) Create() {
	gelly.LogInfo("CREATE")
}

func (s *GesnoEmul) ResetGame() {
	s.mem = go6502.Mem{}
	s.mem.WriteBytes(0x0600, GAME_CODE)
	s.mem.WriteWord(0xFFFC, 0x0600)
	s.cpu = go6502.Cpu{}
	s.cpu.Reset(&s.mem)
}

func (s *GesnoEmul) Init() {
	gelly.LogInfo("INIT")

	s.font = gelly.GetResource().LoadFont(FONT_ROBMED, 24, 72)

	rand.Seed(time.Now().Unix())

	s.ResetGame()

	s.dispatcher = gelly.NewEventDispatch()
	s.dispatcher.Subscribe(gelly.KEYBOARD_PRESSED_EVENT, s.OnKeyPressed)
}

func (s *GesnoEmul) OnKeyPressed(e gelly.Event) {
	keyEvent := e.(gelly.KeyboardPressedEvent)

	switch keyEvent.Key {
	case gelly.Key_W:
		s.mem.Write(0xff, 0x77)
	case gelly.Key_D:
		s.mem.Write(0xff, 0x64)
	case gelly.Key_A:
		s.mem.Write(0xff, 0x61)
	case gelly.Key_S:
		s.mem.Write(0xff, 0x73)
	case gelly.Key_R:
		s.ResetGame()
		s.isLost = false
	}
}

func (s *GesnoEmul) Update(dt gelly.Deltatime) {
	s.mem.Write(0xfe, uint8(rand.Intn(15)+1))

	if !s.isLost {
		mili := dt.GetElapsedMili()

		for i := 0; i < int(mili); i++ {
			for y := 0; y < 10; y++ {
				if s.cpu.Step(&s.mem) {
					s.isLost = true
				}
			}
		}
	}

}

func (s *GesnoEmul) Event(e gelly.Event) {
	s.dispatcher.Publish(e)
}

func (s *GesnoEmul) Draw(dt gelly.Deltatime, r gelly.Renderer) {
	r.Clear(gelly.Color{A: 255})
	r.Begin(gelly.Matrix{Scale: gelly.Vector2{X: 1, Y: 1}})

	r.DrawRect(gelly.Rect{}, gelly.Color{})

	for i := 0; i < GRID_SIZE; i++ {
		color := s.mem.Read(0x0200 + uint16(i))
		gcolor := mapByteToColor(color)

		r.DrawRect(gelly.Rect{
			X: CELL_SIZE * (i % GRID_WIDTH),
			Y: CELL_SIZE * (i / GRID_WIDTH),
			W: CELL_SIZE,
			H: CELL_SIZE,
		}, gcolor)
	}
	r.DrawRect(gelly.Rect{
		X: 0,
		Y: 0,
		W: CELL_SIZE * GRID_WIDTH,
		H: CELL_SIZE * GRID_WIDTH,
	}, gelly.Color{R: 255, G: 255, B: 255, A: 255})

	r.DrawFont(s.font, "GESNO - NES Emulator : SNAKE",
		gelly.Point{X: 740, Y: 40},
		gelly.Color{R: 255, G: 255, B: 255, A: 255},
	)

	r.DrawFont(s.font, fmt.Sprintf("Accumulator: 0x%02x", s.cpu.Accumulator),
		gelly.Point{X: 780, Y: 80},
		gelly.Color{R: 255, G: 255, B: 255, A: 255},
	)

	r.DrawFont(s.font, fmt.Sprintf("Cycles: %d", s.cpu.Cycle),
		gelly.Point{X: 780, Y: 120},
		gelly.Color{R: 255, G: 255, B: 255, A: 255},
	)

	// op := s.mem[s.cpu.ProgramCounter]
	r.DrawFont(s.font, fmt.Sprintf("Operation: 0x%02x", s.mem[s.cpu.ProgramCounter]),
		gelly.Point{X: 780, Y: 160},
		gelly.Color{R: 255, G: 255, B: 255, A: 255},
	)

	if s.isLost {
		r.DrawFont(s.font, "GAME OVER: Press R to Replay",
			gelly.Point{X: 780, Y: 200},
			gelly.Color{R: 255, G: 255, B: 255, A: 255},
		)
	}

	// s.cpu.Registers.Accumulator
	// s.cpu.
	// r.DrawFont()

	r.End()
	r.Flush()
}

// type OperationList struct {
// 	// operations [10]uint8
// 	operations datt.Queue[uint8]
// }

// func (ol *OperationList) Push(ope uint8) {
// 	// queue := datt.NewQueue[uint8]()
// 	if ol.operations.Length() >= 10 {
// 		ol.operations.Dequeue()
// 	}

// 	ol.operations.Enqueue(ope)
// }

// func (ol *OperationList) Draw(r gelly.Renderer) {
// 	// // queue := datt.NewQueue[uint8]()
// 	// if ol.operations.Length() >= 10 {
// 	// 	ol.operations.Dequeue()
// 	// }

// 	// ol.operations.Enqueue(ope)
// }

func (s *GesnoEmul) Dispose() {
	gelly.LogInfo("DISPOSE")
}

var GAME_CODE = []uint8{
	0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
	0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
	0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
	0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
	0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
	0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
	0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
	0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
	0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
	0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
	0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
	0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
	0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
	0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
	0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
	0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
	0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
	0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
	0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
	0xea, 0xca, 0xd0, 0xfb, 0x60,
}
